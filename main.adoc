= What's new with Java
v0.1, 2018-09-19
:author: Davide Angelocola
:firstname: Davide
:lastname: Angelocola
:email: davide.angelocola@gmail.com
:copyright: CC-BY-SA 3.0
:doctype: book
:creator: {author}
:source-highlighter: prettify

== About the Author

You can contact {author} at {email}. {firstname} loves to hear from other developers.

== Introduction

As Java developer we will busy upgrading our code bases to newest Java LTS release: Java 11.
I think it is important to document, with examples, how to take advantage of new Java classes and idioms.
The focus however is on the language level changes, not runtime.

== Principles

* use standard library as much as possible
* examples are compiled with JShell
* step by step migrations

== Upgrade to Java11

Java11 is the new LTS version of java. Once you support this release you can take advantages of all new APIs introduced since Java9.

=== Character.toString(int)

This method returns the string representation for the given Unicode code point as shown below:

[source,java]
----
include::snippets/character_toString.jsh[]
----

=== String.lines()

Sometimes this is very convenient: get a stream divided by line breaks:

[source,java]
----
jshell> "a\nb\nc\n".lines().toUpperCase).toArray()
$1 ==> Object[2] { "A", "B", "C }
----

=== String.lines()

Repeat String for the specified number of times:

[source,java]
----
jshell> "test".repeat(3)
$7 ==> "testtesttest"
----

[NOTE] check bondaries (-1, MAX_VALUE)


=== String.isBlank()

This is correct but too technical, and perhaps the intent is not clear:

    boolean blank = string.codePoints().allMatch(Character::isWhitespace);


https://bugs.openjdk.java.net/browse/JDK-8200437

[source,java]
----
jshell> var halfSpace = "\u0020"
halfSpace ==> " "

jshell> halfSpace.trim()
$2 ==> ""

jshell> var fullSpace = "\u3000"
fullSpace ==> "　"

jshell> fullSpace.trim()
$4 ==> "　"
----



=== String.strip()
While almost the same as  trim()/trimLeft()/trimRight(), this takes full-width spaces as a space.

[source,java]
----
jshell> var halfSpace = "\u0020"
halfSpace ==> " "

jshell> halfSpace.trim()
$2 ==> ""

jshell> var fullSpace = "\u3000"
jshell> fullSpace.trim()
$4 ==> ""
----

.TODO
cover also stripLeading()/stripTrailing()

=== Null objects

https://download.java.net/java/early_access/jdk11/docs/api/java.base/java/io/Reader.html#nullReader()
Reader
nullReader()
We can get a  Reader  that does nothing.

Writer
nullWriter()
We can get a  Writer that does nothing.

InputStream
nullInputStream()
We can get an  InputStream  that does nothing.

OutputStream
nullOutputStream()

== Upgrade to Java10

=== local type inference

This is the big new feature of Java 10, introduced by http://openjdk.java.net/jeps/286

[source,java]
----
include::snippets/java10_var.jsh[]
----


Now it is possible to express things not possible before, use wisely:

[source,java]
----
var a = new Object() {

   void m() {

   }

};

a.m();

----

== Upgrade to Java9

=== JShell


=== Immutable collections

JEP 269 http://openjdk.java.net/jeps/269 introduced some new factory methods for collections.
New APIs are:

[source,java]
----
Set<Integer> set = Set.of(1,2,3,4);
List<Integer> list = List.of(1,2,1,2);
Map<String, Integer> map = Map.of("key1", 1, "key2", 2);
Map<String, Integer> mapLonger = Map.fromEntries(entry("key1", 1), entry("key2", 2));
----

.Immutability vs views
NOTE: copyOf() is a new tool yielding an immutable copy of the datastracture. Collections.unmodificable* are just read-only wrappers around original data structure: if the original datastructure is mutable, you can still see changes in the wrapper.

.Gotcha:
NOTE: cannot use Set.of to filter aways duplicated.

[source,java]
----
jshell> Set.of(1,1)
|  java.lang.IllegalArgumentException thrown: duplicate element: 1
|        at ImmutableCollections$SetN.<init> (ImmutableCollections.java:463)
|        at Set.of (Set.java:521)
----

=== java.util.Optional.stream()

[source,java]
----
List<Optional<String>> listOfOptional = ....;
List<String> filteredList = listOfOptionals.stream()
  .flatMap(Optional::stream)
  .collect(Collectors.toList());
----

=== Version

In legacy codebases it is possible to find some creative code around determining which java version
we are using:

[source,java]
----
String version = Runtime.class.getPackage().getImplementationVersion();
----

[source,java]
----
double version = Double.parseDouble(System.getProperty("java.specification.version"));
----

[source,java]
----
String[] javaVersionElements = System.getProperty("java.runtime.version").split("\\.|_|-b");
----


[source,java]
----
Runtime.Version version = Runtime.version();
----

[source,java]
----
include::snippets/java9_version.jsh[]
----

=== java.lang.ProcessHandle

Obtain information about JVM itself:

[source,java]
----
include::snippets/java9_process_info.jsh[]
----

List all system processes:
[source,java]
----
include::snippets/java9_process_list.jsh[]
----

== Upgrade to Java8

=== java.io.UncheckedIOException

This is a little know class
